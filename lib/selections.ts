/**
 * Selections and Allowances Service
 * Handles creation, updates, and syncing of selections linked to estimate line items
 */

import { createServerClient } from '@/lib/supabase/server'
import { matchTask } from '@/lib/pricing/match-task'
import type { EstimateLineItem, Selection, SelectionInsert, SelectionUpdate } from '@/types/db'

/**
 * Get all selections for an estimate
 */
export async function getSelectionsForEstimate(estimateId: string, userId: string): Promise<Selection[]> {
  const supabase = await createServerClient()

  // Verify ownership through estimate → project
  const { data: estimate, error: estimateError } = await supabase
    .from('estimates')
    .select('id, project_id')
    .eq('id', estimateId)
    .single()

  if (estimateError || !estimate) {
    throw new Error('Estimate not found')
  }

  const { data: project, error: projectError } = await supabase
    .from('projects')
    .select('id, user_id')
    .eq('id', estimate.project_id)
    .single()

  if (projectError || !project || project.user_id !== userId) {
    throw new Error('Unauthorized: Estimate does not belong to user')
  }

  // Fetch selections
  const { data: selections, error: selectionsError } = await supabase
    .from('selections')
    .select('*')
    .eq('estimate_id', estimateId)
    .order('created_at', { ascending: true })

  if (selectionsError) {
    throw new Error(`Failed to load selections: ${selectionsError.message}`)
  }

  return selections || []
}

/**
 * Extract title from description (first sentence or first 50 chars)
 */
function extractTitle(description: string): string {
  if (!description || description.trim().length === 0) {
    return 'Untitled Selection'
  }

  // Try to get first sentence
  const firstSentence = description.split(/[.!?]/)[0].trim()
  if (firstSentence.length > 0 && firstSentence.length <= 100) {
    return firstSentence
  }

  // Fall back to first 50 characters
  return description.substring(0, 50).trim()
}

/**
 * Parse allowance amount from description
 * Matches patterns like "allowance $5000" or "allowance: $3,500.00"
 */
function parseAllowanceFromDescription(description: string): number | null {
  if (!description) return null

  const allowanceRegex = /allowance[^$]*\$(\d[\d,\.]*)/i
  const match = description.match(allowanceRegex)
  
  if (match && match[1]) {
    // Remove commas and parse
    const amountStr = match[1].replace(/,/g, '')
    const amount = parseFloat(amountStr)
    if (!isNaN(amount) && amount > 0) {
      return amount
    }
  }

  return null
}

/**
 * Extract subcontractor name from description
 * Matches patterns like "Subcontractor: Pacific Hearth" or "installed by ABC Company"
 */
function extractSubcontractor(description: string): string | null {
  if (!description) return null

  // Pattern 1: "Subcontractor:" or "Sub-contractor:" followed by name
  const subPattern1 = /(?:sub-?contractor|subs?):\s*([A-Z][A-Za-z\s&]+)/i
  const match1 = description.match(subPattern1)
  if (match1 && match1[1]) {
    return match1[1].trim()
  }

  // Pattern 2: "installed by" or "performed by" followed by name
  const subPattern2 = /(?:installed|performed)\s+by\s+([A-Z][A-Za-z\s&]+)/i
  const match2 = description.match(subPattern2)
  if (match2 && match2[1]) {
    return match2[1].trim()
  }

  return null
}

/**
 * Check if description looks auto-generated (has [AI] tag or is empty)
 */
function isAutoGenerated(description: string | null | undefined): boolean {
  if (!description || description.trim().length === 0) {
    return true
  }
  
  // Check for AI tags
  return /\[AI\]|\[AUTO\]/i.test(description)
}

/**
 * Upsert a selection from a line item
 * Creates or updates a selection based on the line item data
 */
export async function upsertSelectionFromLineItem(
  lineItem: EstimateLineItem & { id?: string; estimate_id?: string },
  userId: string
): Promise<Selection | null> {
  const supabase = await createServerClient()

  // Verify we have required fields
  if (!lineItem.estimate_id) {
    console.warn('upsertSelectionFromLineItem: lineItem missing estimate_id')
    return null
  }

  // Verify ownership
  const { data: estimate, error: estimateError } = await supabase
    .from('estimates')
    .select('id, project_id')
    .eq('id', lineItem.estimate_id)
    .single()

  if (estimateError || !estimate) {
    throw new Error('Estimate not found')
  }

  const { data: project, error: projectError } = await supabase
    .from('projects')
    .select('id, user_id')
    .eq('id', estimate.project_id)
    .single()

  if (projectError || !project || project.user_id !== userId) {
    throw new Error('Unauthorized: Estimate does not belong to user')
  }

  // Determine if this is an allowance line item
  const isAllowance = lineItem.is_allowance || false
  const description = lineItem.description || ''
  const hasAllowancePhrase = /allowance/i.test(description)
  
  // Parse allowance amount if present
  const parsedAllowance = parseAllowanceFromDescription(description)
  
  // Extract subcontractor if present
  const subcontractor = extractSubcontractor(description)

  // Extract title (short field or first sentence of description)
  const title = extractTitle(description)

  // Determine source (default to 'manual' for now)
  const source: 'manual' | 'voice' | 'ai_text' | 'file' = 'manual'

  if (lineItem.selection_id) {
    // Update existing selection
    const { data: existingSelection, error: fetchError } = await supabase
      .from('selections')
      .select('*')
      .eq('id', lineItem.selection_id)
      .single()

    if (fetchError || !existingSelection) {
      console.warn(`Selection ${lineItem.selection_id} not found, creating new one`)
      // Fall through to create new selection
    } else {
      // Update existing selection
      const updateData: SelectionUpdate = {
        title,
        description,
        room: lineItem.room || null,
        cost_code: lineItem.cost_code || null,
      }

      // Update allowance if parsed from description or if is_allowance flag is set
      if (parsedAllowance !== null) {
        updateData.allowance = parsedAllowance
      } else if (isAllowance && existingSelection.allowance === null) {
        // If marked as allowance but no amount found, keep existing or leave null
        // (will be suggested later)
      }

      // Update subcontractor if found
      if (subcontractor) {
        updateData.subcontractor = subcontractor
      }

      const { data: updatedSelection, error: updateError } = await supabase
        .from('selections')
        .update(updateData)
        .eq('id', lineItem.selection_id)
        .select()
        .single()

      if (updateError) {
        throw new Error(`Failed to update selection: ${updateError.message}`)
      }

      return updatedSelection
    }
  }

  // Create new selection
  const insertData: SelectionInsert = {
    estimate_id: lineItem.estimate_id,
    title,
    description,
    room: lineItem.room || null,
    cost_code: lineItem.cost_code || null,
    category: lineItem.category || null,
    allowance: parsedAllowance,
    subcontractor: subcontractor || null,
    source,
  }

  const { data: newSelection, error: insertError } = await supabase
    .from('selections')
    .insert(insertData)
    .select()
    .single()

  if (insertError) {
    throw new Error(`Failed to create selection: ${insertError.message}`)
  }

  // Update line item to reference the new selection
  if (lineItem.id) {
    const lineItemUpdate: any = {
      selection_id: newSelection.id,
    }

    // Set is_allowance flag if appropriate
    if (isAllowance || hasAllowancePhrase || parsedAllowance !== null) {
      lineItemUpdate.is_allowance = true
    }

    const { error: lineItemUpdateError } = await supabase
      .from('estimate_line_items')
      .update(lineItemUpdate)
      .eq('id', lineItem.id)

    if (lineItemUpdateError) {
      console.warn(`Failed to update line item with selection_id: ${lineItemUpdateError.message}`)
      // Don't throw - selection was created successfully
    }
  }

  return newSelection
}

/**
 * Sync line items from a selection
 * Updates all line items that reference this selection based on selection data
 */
export async function syncLineItemFromSelection(
  selectionId: string,
  userId: string
): Promise<void> {
  const supabase = await createServerClient()

  // Load selection and verify ownership
  const { data: selection, error: selectionError } = await supabase
    .from('selections')
    .select('*')
    .eq('id', selectionId)
    .single()

  if (selectionError || !selection) {
    throw new Error('Selection not found')
  }

  // Verify ownership through estimate → project
  const { data: estimate, error: estimateError } = await supabase
    .from('estimates')
    .select('id, project_id')
    .eq('id', selection.estimate_id)
    .single()

  if (estimateError || !estimate) {
    throw new Error('Estimate not found')
  }

  const { data: project, error: projectError } = await supabase
    .from('projects')
    .select('id, user_id')
    .eq('id', estimate.project_id)
    .single()

  if (projectError || !project || project.user_id !== userId) {
    throw new Error('Unauthorized: Selection does not belong to user')
  }

  // Load all line items that reference this selection
  const { data: lineItems, error: lineItemsError } = await supabase
    .from('estimate_line_items')
    .select('*')
    .eq('selection_id', selectionId)

  if (lineItemsError) {
    throw new Error(`Failed to load line items: ${lineItemsError.message}`)
  }

  if (!lineItems || lineItems.length === 0) {
    return // No line items to sync
  }

  // Update each line item
  for (const lineItem of lineItems) {
    const updates: any = {}

    // If selection has allowance and line item is marked as allowance, sync the price
    if (selection.allowance !== null && lineItem.is_allowance === true) {
      updates.client_price = selection.allowance
      // Simple v1: treat allowance as client_price == direct_cost
      updates.direct_cost = selection.allowance
      // Note: total_direct_cost is calculated elsewhere, so we don't set it here
    }

    // Update description if it looks auto-generated
    // Only overwrite if description is empty or has [AI] tag
    if (isAutoGenerated(lineItem.description)) {
      // Build description from selection title and description
      let newDescription = selection.title
      if (selection.description && selection.description.trim().length > 0) {
        newDescription += ': ' + selection.description
      }
      updates.description = newDescription
    }

    // Apply updates if any
    if (Object.keys(updates).length > 0) {
      const { error: updateError } = await supabase
        .from('estimate_line_items')
        .update(updates)
        .eq('id', lineItem.id)

      if (updateError) {
        console.warn(`Failed to sync line item ${lineItem.id}: ${updateError.message}`)
        // Continue with other line items
      }
    }
  }
}

/**
 * Suggest allowance amount for a selection using task library matching
 */
export async function suggestAllowanceForSelection(
  selection: Selection,
  userId: string
): Promise<Selection | null> {
  const supabase = await createServerClient()

  // Verify ownership
  const { data: estimate, error: estimateError } = await supabase
    .from('estimates')
    .select('id, project_id')
    .eq('id', selection.estimate_id)
    .single()

  if (estimateError || !estimate) {
    throw new Error('Estimate not found')
  }

  const { data: project, error: projectError } = await supabase
    .from('projects')
    .select('id, user_id')
    .eq('id', estimate.project_id)
    .single()

  if (projectError || !project || project.user_id !== userId) {
    throw new Error('Unauthorized: Selection does not belong to user')
  }

  // Load user profile settings for region
  const { data: userSettings, error: settingsError } = await supabase
    .from('user_profile_settings')
    .select('region')
    .eq('user_id', userId)
    .maybeSingle()

  const userRegion = userSettings?.region || null

  // Build search description from selection title and description
  const searchDescription = [
    selection.title,
    selection.description
  ].filter(Boolean).join(' ')

  // Use matchTask to find pricing
  try {
    const match = await matchTask({
      description: searchDescription,
      cost_code: selection.cost_code || null,
      region: userRegion,
    })

    if (match && match.task) {
      // Use unit_cost_mid as base, multiply by quantity 1 for now
      const suggestedAmount = match.task.unit_cost_mid || null

      if (suggestedAmount !== null && suggestedAmount > 0) {
        const updateData: SelectionUpdate = {
          suggested_allowance: suggestedAmount,
        }

        // If selection.allowance is NULL, also set it to suggested_allowance
        if (selection.allowance === null) {
          updateData.allowance = suggestedAmount
        }

        const { data: updatedSelection, error: updateError } = await supabase
          .from('selections')
          .update(updateData)
          .eq('id', selection.id)
          .select()
          .single()

        if (updateError) {
          throw new Error(`Failed to update selection: ${updateError.message}`)
        }

        return updatedSelection
      }
    }
  } catch (error) {
    console.warn('Failed to suggest allowance for selection:', error)
    // Don't throw - this is a suggestion, not critical
  }

  return null
}

